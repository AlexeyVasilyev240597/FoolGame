# CardGameFramework
CardGameFramework в рамках проекта fool_pro.
# Основные идеи
CGF – это инструмент для создания простейших карточных игр, которое подразумевает наследование от заранее оговоренных абстрактных классов, далее Высшие классы
 * Правила = RULES
 * Игрок = PLAYER
 * Игра = GAME
 
Для создания новой игры разработчик должен будет описать уникальную грамматику своей игры в своем классе MY_RULES, добавить методы в MY_PLAYER (если это необходимо) и реализовать абстрактный метод MY_GAME::run() в своем классе. (ИЛИ ЖЕ см. БАИ п.1).
Основные объекты, с которым будут иметь дело все Высшие класс – это карты CARD. Карты делятся на Материальные (непосредственно из колоды) и Мыслимые (для проработки стратегий AI, запоминания им вышедших из игры и т.п.).

Все карты хранятся в определенном контейнере - Мыслимые в SET, Материальные в MAT_SET. Первый включает в себя базовые методы работы с контейнерами (getByIndex(), findBySuit() и т.п.), второй содержит методы для взаимодействия игроков и других владельцев карт HOLDER между собой, которое будет строго регулироваться правилами RULES.

Материальные карты в начале находятся в колоде (далее DECK). DECK находится у крупье (далее DEALER). После окончания игры карты возвращаются DEALER-у.

Также существуют средний класс (пока один) HOLDER – владелец карт. Имеются в виду все объекты, у которых могут быть карты в игре – PLAYER, прикуп STOCK, отбой (вышедшие из игры) DISCARD_PILE, они будут его наследниками. У HOLDER-а есть свой MAT_SET.

# Высшие классы
## RULES
Класс RULES содержит список константных указателей на HOLDER-ы игры, правила их взаимодействия и методы для проверки соответствия этим правилам. Далее GAME будет запрашивать у RULES проверки, например, «может ли holder_1 передать карту any_card holder_2?». 

Также RULES знает о начальном количестве карт (при раздаче) у каждого HOLDER-а и их максимально возможном количестве у него за игру. Эта информация используется при инициализации HOLDER-ов (и MAT_SET-ов внутри них) в GAME (конструктор или метод start() ?).

Информация об окончании игры также хранится в RULES (метод bool isGameOver(){return gameOverCondition;}) и о результате, которыйбыл достигнут при этом (например, какой игрок выиграл, или была ничья, или сколько очков набрал игрок и т.п.).

## PLAYER
Класс PLAYER – наследник HOLDER-а. Является прародителем классов PLAYER_USER и PLAYER_AI для игр более чем с одним игровом. В зависимости от бытности одним из них графическая отрисовка карт будет разной. НО их объединяет настройка уровня видимости, которая отличает HOLDER-ов друг от друга – PLAYER-ам не видны карты друг друга (в базовом, простейшем случае; бывает, что один игрок должен показать карту другому – младший козырь для начала хода в Дураке, и другие случаи).

## GAME

# Средства разработки программного обеспечения

Среда разработки:
 * QT Creator 4.7.0
 
Система управления версиями:
 * GitHub

Языки программирования использованные в разработке:
 * С++ 11 версии
 
Графический интерфейс:
 * QT

# Безумно амбициозные идеи.
*	я так сильно постараюсь, что смогу написать этот метод в АБСОЛЮТНО АБСТРАКТНОМ виде ДЛЯ ЛЮБОЙ ИГРЫ, руководствуясь только информацией из класса MY_RULES. Я вижу это так:
**	Разработчик пишет грамматику;
**	CGF проверяет ее на наличие необходимых компонент и отсутствие противоречий;
**	генерирует конфиг-файл, в котором будет цикл (условие выхода – условия окончания игры, чаще всего, когда кончаются карты у одного из HOLDER-ов). Разработчик должен будет, используя свою грамматику, описать процесс игры. Нужно будет предоставить ему различные операторы для этого – логические, условные и т.п.  Много, о чем есть подумать.
*	Написать класс MULTIDECK для возможности играть с несколькими колодами (может быть интересно для игры Верю-не-верю).
