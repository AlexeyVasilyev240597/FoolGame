#include <QApplication>
//#include <QObject>
#include <QDebug>
#include "src/drawing/GameScene.h"
#include "src/fool/Fool.h"

int main(int argc, char *argv[])
{
  QApplication a(argc, argv);

  FOOL_GAME fool;
  FOOL_ITEM_MANAGER manager;
  SCENE_VIEW game_scene(&manager);

  fool.init(&manager);
  fool.game();
  game_scene.show();  

  return a.exec();
}

/*
 * Некоторые замечания и планы:
 *
 *  1. если разрабатывать "Дурака" с тремя и более игроками,
 * то имеет смысл параметризовать класс RULES количеством игроков,
 * также параметром может быть объем колоды и, возможно, их количество
 * (в этом случае нужно написать класс MULTIDECK);
 *
 *  2. классы DEALER и FOOL_GAME должны быть singletone,
 * а RULES иметь protected конструктор;
 *
 *  3. нужно создать gui_dealer, который будет содержать gui_deck,
 * в котором в свою очередь вектор CARD_ITEM, их будем распределять между
 * item-ами элементов, а не создавать каждый раз новые.
 * И вообще графическое представление карт будет только за счет CARD_BTN,
 * но включать доступ к кнопкам будем, когда они у user-a.
 * Лучше не инкапсулировать CARD* в CARD_BTN, потому что каждая задница
 * владеет своим указателем на карту и мало ли, что может с ним сделать,
 * теряется единственность и уникальность карты(может ее тоже сделать singletone?);
 *
 *  4. когда разработка CARD_BTN будет закончена нужно разобраться с access у элемента:
 * зачем в этом enum поле TO_HOLDER, если невозможно проверить,
 * кто пытается изменить face_state карты, или кто запрашивает информаци о ней.
 * В процессе отрисовки карты нужно будет пользоваться face_state;
 *
 *  5. нужно создать gui-аналог ELEMENT, переделать под него MY_ITEM:
 * там должны быть свои giveCard(), addCard(), это будут слоты, которые свяжем с
 * сигналами от элемента, например в методе DEALER::exchange();
 *
 *  6. разнести поля классов по секциям public, protected и private наконец
*/
